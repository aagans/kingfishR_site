[
  {
    "objectID": "document_dir/basics/working_r.html",
    "href": "document_dir/basics/working_r.html",
    "title": "Variables and Arithmetic",
    "section": "",
    "text": "Unlike other statistical programs you may be familiar with, such as Prism, R does not have a GUI (graphical user interface). Rather, R is a programming language. Instead of clicking buttons and choosing a specific statistical test from a list, you have to build a command and run it.\nAt the most basic level, R is about loading data into objects (also called variables), doing something to that object using a function, and outputting that modified data to a new object. In order to assign data to an object, one uses an assignment operator. For example:\n\nobject_1 &lt;- 1\nanother_object &lt;- object_1 + object_1\nprint(another_object)\n\n[1] 2\n\n\n\n\nIn this case, we assigned the value 1 to the variable object_1 using the assignment operator &lt;-. Whatever is to the left of the assignment operator is the name of the variable. Whatever is to the right of the operator is the data object the variable name is assigned to.\n\n\n\nVariables can be as simple as a number such as 1 to as complex as a data set composed of hundreds of rows and columns. Variable names can be composed of any alphanumeric characters along with periods and underscores. However, the variable name can not start with a number or an underscore. Which variable assignments would work?\n1var1 &lt;- 5\nvar2 &lt;- \"hello!\"\n23var &lt;- \"Cats are cool\"\n\n1\n\nThis would work!\n\n2\n\nThis one starts with a number, so it would not work\n\n\nVariables are going to store data that you work with throughout your R script, so there are a few conventions on how to name them to make their use as easy as possible. Try to aim for short and descriptive variable names. If you have to repeatedly use the variable, a variable name that is long will be cumbersome to use. Additionally, for ease of reading your code, a descriptive name of what the object is makes it easier for understanding what is going on. For example:\nlist_of_my_favorite_odd_numbers &lt;- c(1,9,19) \n#This is a long name! \n#Do you want to have to type it everytime you want to use this object?\n\nvar1 &lt;- 15 \n#This name is not descriptive. \n#When you later use var1 in your script, are you going to know what it stores?\n\n#Lets try to improve those names\nfav_odd_nums &lt;- c(1,9,19)\n#This is shorter than the original but just as descriptive\n\nfifteen &lt;- 15\n#Concise and descriptive!\nAnother convention is how to separate words in your variable name. R will not allow you to put spaces in a variable name, as it interprets that as two different variables. The R style guide recommends using underscores (_) as the connector between words in your variable name. This style is called Snake Case, for it was popularized by the programming language Python. An example are the variables with multiple words in the above code blocks. Three other naming conventions that are common in R are Pascale Case, Camel Case and Period Separated.\nsnake_case &lt;- \"This is Snake Case because the words are separated by an _\"\nPascaleCase &lt;- \"Each word is capitalized in Pascale Case\"\ncamelCase &lt;- \"Words after the first one are capitalized in Camel Case\"\nperiod.separated &lt;- \"Words are separated by a period\"\nWhile there is no functional reason to not use these styles, the R style guide does suggest the usage of Snake Case due to removing ambiguity. However, this is a recent change. If you look at older R code, you will see that the Period Separated convention is widely used.\nPlease just try to stay consistent in your naming conventions, and while we recommend the usage of Snake Case, it is not required.\n\n\n\n\n\n\nTip\n\n\n\nR is case sensitive! A variable name of years_since_x is not the same as Years_since_x or any other variation. R is extremely pedantic, it will do exactly what you tell it to do, not what you want it to do. Creating different variables that only differ in case is highly discouraged due to a high chance of later confusion.\n\n\n\n\n\nR has many other operators that can be used beyond the assignment operator. Listed below are additional assignment and arithmetic operators. Other operators do exist and will be explained in a later section.\n\n\n\n\n\n\n\n\n\nName\nType\nSymbol\nUsage\n\n\n\n\nVariable assignment operator\nAssignment\n&lt;-\nAssign an object to a variable name\n\n\nParameter assignment operator\nAssignment\n=\nAssign an object to a parameter in a function\n\n\nAddition operator\nArithmetic\n+\nAdd numerics together\n\n\nSubtraction operator\nArithmetic\n-\nSubtracts numerics from one another\n\n\nMultiplication operator\nArithmetic\n*\nMultiplies numerics together\n\n\nDivision operator\nArithmetic\n/\nDivides numerics\n\n\nExponent operator\nArithmetic\n^\nFinds the value of a numeric to a given exponent\n\n\nModulus operator\nArithmetic\n%%\nReturns the remainder when dividing numerics\n\n\nInteger division operator\nArithmetic\n%/%\nReturns a numeric truncated to the nearest integer when dividing numerics\n\n\n\n\n12 + 5\n10 - 3\n3*4\n76/4\n4^2\n12%%5\n24%/%5\n\n[1] 17\n[1] 7\n[1] 12\n[1] 19\n[1] 16\n[1] 2\n[1] 4\n\n\nOne core aspect of R arithmetic operators is that they are vectorized (we will cover vectors next!). If you have a vector containing multiple numbers and add it to a different vector containing other numbers, the first set of numbers will be added together, and so will the second set, and so on until every element set is added together.\n\nvec_1 &lt;- c(1,2,3)\nvec_2 &lt;- c(10, 20, 30)\nvec_1 + vec_2\n\n[1] 11 22 33"
  },
  {
    "objectID": "document_dir/basics/working_r.html#r-syntax-structure",
    "href": "document_dir/basics/working_r.html#r-syntax-structure",
    "title": "Variables and Arithmetic",
    "section": "",
    "text": "Unlike other statistical programs you may be familiar with, such as Prism, R does not have a GUI (graphical user interface). Rather, R is a programming language. Instead of clicking buttons and choosing a specific statistical test from a list, you have to build a command and run it.\nAt the most basic level, R is about loading data into objects (also called variables), doing something to that object using a function, and outputting that modified data to a new object. In order to assign data to an object, one uses an assignment operator. For example:\n\nobject_1 &lt;- 1\nanother_object &lt;- object_1 + object_1\nprint(another_object)\n\n[1] 2\n\n\n\n\nIn this case, we assigned the value 1 to the variable object_1 using the assignment operator &lt;-. Whatever is to the left of the assignment operator is the name of the variable. Whatever is to the right of the operator is the data object the variable name is assigned to.\n\n\n\nVariables can be as simple as a number such as 1 to as complex as a data set composed of hundreds of rows and columns. Variable names can be composed of any alphanumeric characters along with periods and underscores. However, the variable name can not start with a number or an underscore. Which variable assignments would work?\n1var1 &lt;- 5\nvar2 &lt;- \"hello!\"\n23var &lt;- \"Cats are cool\"\n\n1\n\nThis would work!\n\n2\n\nThis one starts with a number, so it would not work\n\n\nVariables are going to store data that you work with throughout your R script, so there are a few conventions on how to name them to make their use as easy as possible. Try to aim for short and descriptive variable names. If you have to repeatedly use the variable, a variable name that is long will be cumbersome to use. Additionally, for ease of reading your code, a descriptive name of what the object is makes it easier for understanding what is going on. For example:\nlist_of_my_favorite_odd_numbers &lt;- c(1,9,19) \n#This is a long name! \n#Do you want to have to type it everytime you want to use this object?\n\nvar1 &lt;- 15 \n#This name is not descriptive. \n#When you later use var1 in your script, are you going to know what it stores?\n\n#Lets try to improve those names\nfav_odd_nums &lt;- c(1,9,19)\n#This is shorter than the original but just as descriptive\n\nfifteen &lt;- 15\n#Concise and descriptive!\nAnother convention is how to separate words in your variable name. R will not allow you to put spaces in a variable name, as it interprets that as two different variables. The R style guide recommends using underscores (_) as the connector between words in your variable name. This style is called Snake Case, for it was popularized by the programming language Python. An example are the variables with multiple words in the above code blocks. Three other naming conventions that are common in R are Pascale Case, Camel Case and Period Separated.\nsnake_case &lt;- \"This is Snake Case because the words are separated by an _\"\nPascaleCase &lt;- \"Each word is capitalized in Pascale Case\"\ncamelCase &lt;- \"Words after the first one are capitalized in Camel Case\"\nperiod.separated &lt;- \"Words are separated by a period\"\nWhile there is no functional reason to not use these styles, the R style guide does suggest the usage of Snake Case due to removing ambiguity. However, this is a recent change. If you look at older R code, you will see that the Period Separated convention is widely used.\nPlease just try to stay consistent in your naming conventions, and while we recommend the usage of Snake Case, it is not required.\n\n\n\n\n\n\nTip\n\n\n\nR is case sensitive! A variable name of years_since_x is not the same as Years_since_x or any other variation. R is extremely pedantic, it will do exactly what you tell it to do, not what you want it to do. Creating different variables that only differ in case is highly discouraged due to a high chance of later confusion.\n\n\n\n\n\nR has many other operators that can be used beyond the assignment operator. Listed below are additional assignment and arithmetic operators. Other operators do exist and will be explained in a later section.\n\n\n\n\n\n\n\n\n\nName\nType\nSymbol\nUsage\n\n\n\n\nVariable assignment operator\nAssignment\n&lt;-\nAssign an object to a variable name\n\n\nParameter assignment operator\nAssignment\n=\nAssign an object to a parameter in a function\n\n\nAddition operator\nArithmetic\n+\nAdd numerics together\n\n\nSubtraction operator\nArithmetic\n-\nSubtracts numerics from one another\n\n\nMultiplication operator\nArithmetic\n*\nMultiplies numerics together\n\n\nDivision operator\nArithmetic\n/\nDivides numerics\n\n\nExponent operator\nArithmetic\n^\nFinds the value of a numeric to a given exponent\n\n\nModulus operator\nArithmetic\n%%\nReturns the remainder when dividing numerics\n\n\nInteger division operator\nArithmetic\n%/%\nReturns a numeric truncated to the nearest integer when dividing numerics\n\n\n\n\n12 + 5\n10 - 3\n3*4\n76/4\n4^2\n12%%5\n24%/%5\n\n[1] 17\n[1] 7\n[1] 12\n[1] 19\n[1] 16\n[1] 2\n[1] 4\n\n\nOne core aspect of R arithmetic operators is that they are vectorized (we will cover vectors next!). If you have a vector containing multiple numbers and add it to a different vector containing other numbers, the first set of numbers will be added together, and so will the second set, and so on until every element set is added together.\n\nvec_1 &lt;- c(1,2,3)\nvec_2 &lt;- c(10, 20, 30)\nvec_1 + vec_2\n\n[1] 11 22 33"
  },
  {
    "objectID": "document_dir/basics/data_types.html",
    "href": "document_dir/basics/data_types.html",
    "title": "Objects and Data Structures",
    "section": "",
    "text": "Now you know about variables, but what can you store in one? The short answer is everything! R has a wide variety of different data types that are used for different things. I will break down the most common ones you will use in this section. First, there are two distinct categories of data types: atomic data types and data structures.\n\n\nAtomic data types are the most simple data types in R. These are the building blocks of data structures. Base R has the following atomic data types that you will commonly use:\n\nLogical - TRUE or FALSE\nNumeric - 1 or 1.574, or pi\ncharacter - “hello!”, “a”, “STRING”\n\nWhile these data types are simple, they each have their own quirks that can cause confusion when they are first used.\nAdditionally, R does have other atomic data types that this guide will not cover here. They are either not widely used or are for have more advanced use-cases.\n\n\nLogicals are a binary data type, either being TRUE or FALSE. They must be upper case or else R interprets it as a variable name. Additionally, R interprets TRUE as 1 and FALSE as 0, leading to interesting results when this data type is used with numerics. For example, see what happens when you add TRUE to 5:\n\nTRUE + 5\n\n[1] 6\n\n\nThis functionality can be useful in some cases, but just be aware of it in case you are getting results that do not make sense to you when dealing with logicals. Their primary use is in conditional functions, which we will explore later in this guide.\n\n\n\nNumerics, also called doubles, are numbers. This can be either whole numbers, such as 9 or 3948, or they can be decimals, such as 8.47 or 937.5\n\ntypeof(584)\ntypeof(98.37483277777)\ntypeof(pi)\n\n[1] \"double\"\n[1] \"double\"\n[1] \"double\"\n\n\n\n\n\nCharacter vectors, also called strings, are a set of text characters. Anything located between a pair of double or single quotes will be considered as a character vector. This includes numbers, text, and symbols. If you want to have your character vector contain quotes, you can use a set of single quotes instead of double quotes and vice versa.\nthis_is_a_character_vector &lt;- \"Hi! Many different symbols can be in a character\"\nquotes_in_string &lt;- 'I have switched to \"single quotes\" to allow double quotes'\n\n\n\n\nData structures are more complex data types that are made of the different atomic data types. The most commonly used data structures include:\n\nVectors\nLists\nMatrices\nData frames\nFactors\n\nLets go over what differentiates these data structures.\n\n\nVectors are the most common data structure. They are made of multiple objects of a single atomic data type. The most common way to create a vector is the concatenate function, c(), where each atomic object is separated by a comma:\n\nnum_vector &lt;- c(1, 2, 3)\nnum_vector\n\n[1] 1 2 3\n\n\nVectors are useful as a lot of R functions are vectorized, meaning one function is applied to every object in the given vector.\n\nadding_two &lt;- num_vector + 2\nadding_two\n\n[1] 3 4 5\n\n\nThe most important thing to remember about vectors is that they can only contain one type of atomic data objects. Lets see when we try to break that!\n\nbroken_vector &lt;- c(1, 2, \"hi\")\nbroken_vector\n\n[1] \"1\"  \"2\"  \"hi\"\n\n\nAs you can see, R has converted the numerics 1 and 2 into characters in order for the vector to be created. Be careful of these conversions, as it can cause unintended consequences.\n\n\n\nSo what if you want to have a vector that contains different data types? Well, then you use lists! Lists are just like vectors in that they hold multiple objects, just they are not limited to a single data type. A list can even contain vectors or other lists.\n\ncool_list &lt;- list(1, TRUE, c(\"vector\", \"in\", \"a\", \"list\"))\ncool_list\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] TRUE\n\n[[3]]\n[1] \"vector\" \"in\"     \"a\"      \"list\"  \n\n\n\n\n\nMatrices (the plural for matrix) are two-dimensional vectors. They are made of rows and columns, but every data object stored in them must be of the same type. This means if you store numerics in a matrix, that matrix will only store numerics.\n\nmy_matrix &lt;- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE)\nmy_matrix\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n\n#What happens when we try to change one of the data objects in the matrix to a character?\nmy_matrix[1,1] &lt;- \"hi\"\nmy_matrix #It converts all of the data objects into characters!\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"hi\" \"5\"  \"9\"  \"13\" \"17\"\n[2,] \"2\"  \"6\"  \"10\" \"14\" \"18\"\n[3,] \"3\"  \"7\"  \"11\" \"15\" \"19\"\n[4,] \"4\"  \"8\"  \"12\" \"16\" \"20\"\n\n\nWhile matrices are computationally fast due to their simplicity, their limitations can be too restrictive. Additionally, the conversion of object types can cause confusion in downstream applications. This is why we mainly use data frames!\n\n\n\nData frames are to lists what matrices are to vectors. Rather than being limited to the whole object only containing one data type, each column can contain a different data type. This means if you have a spreadsheet of names and heights, you can have one column contain characters (names), and the other column contain numbers (height in inches) without having R convert either column into a different type.\n\nmy_dataframe &lt;- data.frame(Name = c(\"Crosby\", \"Stills\", \"Nash\"), Height = c(70, 68, 72), Nationality = c(\"American\", \"American\", \"British\"))\nmy_dataframe\n\n    Name Height Nationality\n1 Crosby     70    American\n2 Stills     68    American\n3   Nash     72     British\n\n\nData frames will be used greatly throughout this guide due to the versatility and ease of use. Most data sets you will create and explore in biology will work best in this data type, so make sure you understand what differentiates a data frame from the other data structures discussed above!\n\n\nThere are a set of operators related to working with data frames that allow one to extract specific sets of data from the object.\n\n\n\n\n\n\n\n\n\nName\nSymbol\nType\nUsage\n\n\n\n\nNamed element extrator\n$\nSlice\nExtracts and returns the element of a given name, such as a named column\n\n\nSlice list extractor\n[]\nSlice\nExtracts element(s) at a given index location and returns a list of values\n\n\nSlice element extractor\n[[]]\nSlice\nExtracts and returns element(s) at a given index location\n\n\n\n\nmy_dataframe$Name\n\n#The first value in the slice list extractor is the row index number\n#The second value is the column index number, and they are separated by a comma\nmy_dataframe[1,1]\n\n#You can also keep oen of the arguments empty to return all of that type\nmy_dataframe[1,] #Returns all columns of the first row\n\n#If you want to return the element and not a list containing the element, use [[]]\nmy_dataframe[[1,1]]\n\n[1] \"Crosby\" \"Stills\" \"Nash\"  \n[1] \"Crosby\"\n    Name Height Nationality\n1 Crosby     70    American\n[1] \"Crosby\"\n\n\n\n\n\n\n\nThere are three ways to represent missing data in R. For data that does not exist, R has the object NULL. Setting a variable equal to NULL is a way to delete the object that variable is assigned to. If a value is unknown but does exist, then R uses the object NA. Then, in the case of impossible values, such as dividing by zero, R has the object NaN, or not a number."
  },
  {
    "objectID": "document_dir/basics/data_types.html#data-types",
    "href": "document_dir/basics/data_types.html#data-types",
    "title": "Objects and Data Structures",
    "section": "",
    "text": "Now you know about variables, but what can you store in one? The short answer is everything! R has a wide variety of different data types that are used for different things. I will break down the most common ones you will use in this section. First, there are two distinct categories of data types: atomic data types and data structures.\n\n\nAtomic data types are the most simple data types in R. These are the building blocks of data structures. Base R has the following atomic data types that you will commonly use:\n\nLogical - TRUE or FALSE\nNumeric - 1 or 1.574, or pi\ncharacter - “hello!”, “a”, “STRING”\n\nWhile these data types are simple, they each have their own quirks that can cause confusion when they are first used.\nAdditionally, R does have other atomic data types that this guide will not cover here. They are either not widely used or are for have more advanced use-cases.\n\n\nLogicals are a binary data type, either being TRUE or FALSE. They must be upper case or else R interprets it as a variable name. Additionally, R interprets TRUE as 1 and FALSE as 0, leading to interesting results when this data type is used with numerics. For example, see what happens when you add TRUE to 5:\n\nTRUE + 5\n\n[1] 6\n\n\nThis functionality can be useful in some cases, but just be aware of it in case you are getting results that do not make sense to you when dealing with logicals. Their primary use is in conditional functions, which we will explore later in this guide.\n\n\n\nNumerics, also called doubles, are numbers. This can be either whole numbers, such as 9 or 3948, or they can be decimals, such as 8.47 or 937.5\n\ntypeof(584)\ntypeof(98.37483277777)\ntypeof(pi)\n\n[1] \"double\"\n[1] \"double\"\n[1] \"double\"\n\n\n\n\n\nCharacter vectors, also called strings, are a set of text characters. Anything located between a pair of double or single quotes will be considered as a character vector. This includes numbers, text, and symbols. If you want to have your character vector contain quotes, you can use a set of single quotes instead of double quotes and vice versa.\nthis_is_a_character_vector &lt;- \"Hi! Many different symbols can be in a character\"\nquotes_in_string &lt;- 'I have switched to \"single quotes\" to allow double quotes'\n\n\n\n\nData structures are more complex data types that are made of the different atomic data types. The most commonly used data structures include:\n\nVectors\nLists\nMatrices\nData frames\nFactors\n\nLets go over what differentiates these data structures.\n\n\nVectors are the most common data structure. They are made of multiple objects of a single atomic data type. The most common way to create a vector is the concatenate function, c(), where each atomic object is separated by a comma:\n\nnum_vector &lt;- c(1, 2, 3)\nnum_vector\n\n[1] 1 2 3\n\n\nVectors are useful as a lot of R functions are vectorized, meaning one function is applied to every object in the given vector.\n\nadding_two &lt;- num_vector + 2\nadding_two\n\n[1] 3 4 5\n\n\nThe most important thing to remember about vectors is that they can only contain one type of atomic data objects. Lets see when we try to break that!\n\nbroken_vector &lt;- c(1, 2, \"hi\")\nbroken_vector\n\n[1] \"1\"  \"2\"  \"hi\"\n\n\nAs you can see, R has converted the numerics 1 and 2 into characters in order for the vector to be created. Be careful of these conversions, as it can cause unintended consequences.\n\n\n\nSo what if you want to have a vector that contains different data types? Well, then you use lists! Lists are just like vectors in that they hold multiple objects, just they are not limited to a single data type. A list can even contain vectors or other lists.\n\ncool_list &lt;- list(1, TRUE, c(\"vector\", \"in\", \"a\", \"list\"))\ncool_list\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] TRUE\n\n[[3]]\n[1] \"vector\" \"in\"     \"a\"      \"list\"  \n\n\n\n\n\nMatrices (the plural for matrix) are two-dimensional vectors. They are made of rows and columns, but every data object stored in them must be of the same type. This means if you store numerics in a matrix, that matrix will only store numerics.\n\nmy_matrix &lt;- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE)\nmy_matrix\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n\n#What happens when we try to change one of the data objects in the matrix to a character?\nmy_matrix[1,1] &lt;- \"hi\"\nmy_matrix #It converts all of the data objects into characters!\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"hi\" \"5\"  \"9\"  \"13\" \"17\"\n[2,] \"2\"  \"6\"  \"10\" \"14\" \"18\"\n[3,] \"3\"  \"7\"  \"11\" \"15\" \"19\"\n[4,] \"4\"  \"8\"  \"12\" \"16\" \"20\"\n\n\nWhile matrices are computationally fast due to their simplicity, their limitations can be too restrictive. Additionally, the conversion of object types can cause confusion in downstream applications. This is why we mainly use data frames!\n\n\n\nData frames are to lists what matrices are to vectors. Rather than being limited to the whole object only containing one data type, each column can contain a different data type. This means if you have a spreadsheet of names and heights, you can have one column contain characters (names), and the other column contain numbers (height in inches) without having R convert either column into a different type.\n\nmy_dataframe &lt;- data.frame(Name = c(\"Crosby\", \"Stills\", \"Nash\"), Height = c(70, 68, 72), Nationality = c(\"American\", \"American\", \"British\"))\nmy_dataframe\n\n    Name Height Nationality\n1 Crosby     70    American\n2 Stills     68    American\n3   Nash     72     British\n\n\nData frames will be used greatly throughout this guide due to the versatility and ease of use. Most data sets you will create and explore in biology will work best in this data type, so make sure you understand what differentiates a data frame from the other data structures discussed above!\n\n\nThere are a set of operators related to working with data frames that allow one to extract specific sets of data from the object.\n\n\n\n\n\n\n\n\n\nName\nSymbol\nType\nUsage\n\n\n\n\nNamed element extrator\n$\nSlice\nExtracts and returns the element of a given name, such as a named column\n\n\nSlice list extractor\n[]\nSlice\nExtracts element(s) at a given index location and returns a list of values\n\n\nSlice element extractor\n[[]]\nSlice\nExtracts and returns element(s) at a given index location\n\n\n\n\nmy_dataframe$Name\n\n#The first value in the slice list extractor is the row index number\n#The second value is the column index number, and they are separated by a comma\nmy_dataframe[1,1]\n\n#You can also keep oen of the arguments empty to return all of that type\nmy_dataframe[1,] #Returns all columns of the first row\n\n#If you want to return the element and not a list containing the element, use [[]]\nmy_dataframe[[1,1]]\n\n[1] \"Crosby\" \"Stills\" \"Nash\"  \n[1] \"Crosby\"\n    Name Height Nationality\n1 Crosby     70    American\n[1] \"Crosby\"\n\n\n\n\n\n\n\nThere are three ways to represent missing data in R. For data that does not exist, R has the object NULL. Setting a variable equal to NULL is a way to delete the object that variable is assigned to. If a value is unknown but does exist, then R uses the object NA. Then, in the case of impossible values, such as dividing by zero, R has the object NaN, or not a number."
  },
  {
    "objectID": "document_dir/basics/extending_r.html",
    "href": "document_dir/basics/extending_r.html",
    "title": "Extending R",
    "section": "",
    "text": "One of the things that makes R so widely used is the extensive package system. Packages are collections of functions and object types made by other R users to extend the abilities of R. For example, if you were asked to run a set of statistical analyses on a data set in R, you have a few options. You could manually write out the steps of the analysis using the base R functions or you could install and use a package that implements those analyses for you! If you need to do something in R, chances are there is a package you can use that will make that easier.\n\n\n\n\n\nThe largest repository of R packages can be installed from CRAN through a function with only the name of the package needed. For example, if I wanted to install the vegan package, which is a widely used ecological analysis package, I can use this command:\ninstall.packages(\"vegan\")\nThis will then install that package to your R environment. However, if you are on the Bowdoin RStudio server, then the vast majority of packages you may need are already installed. As such, this command is restricted. If you absolutely need to have access to a package not already installed, you can override this restriction by modifying the command:\nutils::install.packages(\"vegan\")\nThis will then install the package to your local Microwave drive and allow you access to the package. The package will only be available to your local R environment, so if someone else needs to use the package, they will have to install it directly as well.\n\n\n\nFor many biology-specific packages, they are accessible from the Bioconductor repository. To install packages from there, you first have to install the Bioconductor core package, then you can install the package you wish to use.\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\") #Installs the core package\nBiocManager::install() #Installs Bioconductor\nBiocManager::install(\"treeio\") #Installs the treeio package\n\n\n\nAdditionally, there is a separate installation method for packages that are not in either of these repositories but are on Github, a code repository site used in industry and academia.\ndevtools::install_github('author_name/repository')\n\n\n\n\nNow that you have a package installed, you have to tell R that it exists so that you can use it. To do so, you use the library() command.\nlibrary(package_name)\n\n\n\n\n\n\nNote\n\n\n\nUnlike installing packages, the package name does not have to be in a set of quotes. This is to make it easier to load packages.\n\n\nThis command can load any package that is installed and will automatically load any other packages that are required for the package to function.\nYou can also see what packages are available and loaded in the Packages tab located in the bottom right panel of RStudio. You can select the check boxes besides packages to load and unload them as well."
  },
  {
    "objectID": "document_dir/basics/extending_r.html#packages",
    "href": "document_dir/basics/extending_r.html#packages",
    "title": "Extending R",
    "section": "",
    "text": "One of the things that makes R so widely used is the extensive package system. Packages are collections of functions and object types made by other R users to extend the abilities of R. For example, if you were asked to run a set of statistical analyses on a data set in R, you have a few options. You could manually write out the steps of the analysis using the base R functions or you could install and use a package that implements those analyses for you! If you need to do something in R, chances are there is a package you can use that will make that easier.\n\n\n\n\n\nThe largest repository of R packages can be installed from CRAN through a function with only the name of the package needed. For example, if I wanted to install the vegan package, which is a widely used ecological analysis package, I can use this command:\ninstall.packages(\"vegan\")\nThis will then install that package to your R environment. However, if you are on the Bowdoin RStudio server, then the vast majority of packages you may need are already installed. As such, this command is restricted. If you absolutely need to have access to a package not already installed, you can override this restriction by modifying the command:\nutils::install.packages(\"vegan\")\nThis will then install the package to your local Microwave drive and allow you access to the package. The package will only be available to your local R environment, so if someone else needs to use the package, they will have to install it directly as well.\n\n\n\nFor many biology-specific packages, they are accessible from the Bioconductor repository. To install packages from there, you first have to install the Bioconductor core package, then you can install the package you wish to use.\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\") #Installs the core package\nBiocManager::install() #Installs Bioconductor\nBiocManager::install(\"treeio\") #Installs the treeio package\n\n\n\nAdditionally, there is a separate installation method for packages that are not in either of these repositories but are on Github, a code repository site used in industry and academia.\ndevtools::install_github('author_name/repository')\n\n\n\n\nNow that you have a package installed, you have to tell R that it exists so that you can use it. To do so, you use the library() command.\nlibrary(package_name)\n\n\n\n\n\n\nNote\n\n\n\nUnlike installing packages, the package name does not have to be in a set of quotes. This is to make it easier to load packages.\n\n\nThis command can load any package that is installed and will automatically load any other packages that are required for the package to function.\nYou can also see what packages are available and loaded in the Packages tab located in the bottom right panel of RStudio. You can select the check boxes besides packages to load and unload them as well."
  },
  {
    "objectID": "document_dir/basics/extending_r.html#user-defined-functions",
    "href": "document_dir/basics/extending_r.html#user-defined-functions",
    "title": "Extending R",
    "section": "User-defined Functions",
    "text": "User-defined Functions\n\nWhat are they?\nUser-defined functions are functions that are made by you for your use. By making your own function, you can turn a multistep process that you may need to run many times into something that can be done in a single line of R code.\nFor example, if you had to regularly edit a data frame, find the mean of the values in a specific column, and create a new data frame using another set of rows, Instead of writing out the list of functions to do this every time it is needed, you can simply write it once when you declare your function and then use that single function to get your results.\n\n\nSyntax\nMaking your own functions follows a simple syntax that uses function()\nfunction_name &lt;- function(parameter1, parameter2) {\n  var1 &lt;- parameter1*parameter2\n  var2 &lt;- var1+parameter2*mean(c(parameter1, parameter2))\n  return(var2)\n  }\nThe name of your function is the variable you are assigning the function() call to. Any parameters necessary for your function are declared within the function() call. Then, in the curly braces, you write the functions that are done when you use your function. You then finish with the return() function. The variable in the return() function is what your function will output when used.\nOnce declared, you can then use your function like you would use any other function."
  },
  {
    "objectID": "document_dir/basics/bool_logic.html",
    "href": "document_dir/basics/bool_logic.html",
    "title": "Boolean Logic",
    "section": "",
    "text": "A common practice in statistics and programming in general is comparing data in specific ways. When an evaluation only can return true or false, then that is an example of Boolean logic. For example, if I asked you if the number 1 is in the set of all odd numbers, then the answer would be true. Additionally, if I asked if 5 equals 84, then you would say false. By using Boolean operators, R can evaluate logic expressions and return the logical data type TRUE or FALSE. In addition to the logicals, R treats the number 0 as false and 1 as true.\n\n\nR uses a set of Boolean operators to build comparison expressions.\n\n\n\n\n\n\n\n\n\nName\nType\nSymbol\nUsage\n\n\n\n\nGreater than operator\nComparison\n&gt;\nChecks if an object is greater than another object\n\n\nLess than operator\nComparison\n&lt;\nChecks if an object is less than another object\n\n\nEquals operator\nComparison\n==\nCheck if two objects are equal to each other\n\n\nGreater than or equals to operator\nComparison\n&gt;=\nChecks if an object is greater than or equal to another object\n\n\nLess than or equals to operator\nComparison\n&lt;=\nChecks if an object is less than or equal to another object\n\n\nNot equal operator\nComparison\n!=\nChecks if an object is not equal to another object\n\n\nAND operator\nLogical\n&\nReturns true if both objects are true\n\n\nOR operator\nLogical\n|\nReturns true if at least one of the objects is true\n\n\nNOT operator\nLogical\n!\nReturns the opposite logical value of a given object\n\n\nIN operator\nLogical\n%in%\nDetermines if a given object is within another object\n\n\n\nA common function used with logical expressions is the which() function. By giving it a logical expression, it will return the index values of items in a vector-like object that match the expression. For example if I had a data set of famous biologists and I wanted to find which of them specialized in genetics, I would use the which() function.\n\nfamous_biologists &lt;- data.frame(first_name = c(\"Charles\", \"Barbara\", \"Gregor\"),\n                                last_name = c(\"Darwin\", \"McClintock\", \"Mendel\"),\n                                subfield = c(\"evolution\", \"genetics\", \"genetics\"))\nwhich(famous_biologists$subfield == \"genetics\")\n\n[1] 2 3\n\n\nThese results mean that rows 2 and 3 have their sub field category equal to genetics."
  },
  {
    "objectID": "document_dir/basics/bool_logic.html#boolean-operators",
    "href": "document_dir/basics/bool_logic.html#boolean-operators",
    "title": "Boolean Logic",
    "section": "",
    "text": "R uses a set of Boolean operators to build comparison expressions.\n\n\n\n\n\n\n\n\n\nName\nType\nSymbol\nUsage\n\n\n\n\nGreater than operator\nComparison\n&gt;\nChecks if an object is greater than another object\n\n\nLess than operator\nComparison\n&lt;\nChecks if an object is less than another object\n\n\nEquals operator\nComparison\n==\nCheck if two objects are equal to each other\n\n\nGreater than or equals to operator\nComparison\n&gt;=\nChecks if an object is greater than or equal to another object\n\n\nLess than or equals to operator\nComparison\n&lt;=\nChecks if an object is less than or equal to another object\n\n\nNot equal operator\nComparison\n!=\nChecks if an object is not equal to another object\n\n\nAND operator\nLogical\n&\nReturns true if both objects are true\n\n\nOR operator\nLogical\n|\nReturns true if at least one of the objects is true\n\n\nNOT operator\nLogical\n!\nReturns the opposite logical value of a given object\n\n\nIN operator\nLogical\n%in%\nDetermines if a given object is within another object\n\n\n\nA common function used with logical expressions is the which() function. By giving it a logical expression, it will return the index values of items in a vector-like object that match the expression. For example if I had a data set of famous biologists and I wanted to find which of them specialized in genetics, I would use the which() function.\n\nfamous_biologists &lt;- data.frame(first_name = c(\"Charles\", \"Barbara\", \"Gregor\"),\n                                last_name = c(\"Darwin\", \"McClintock\", \"Mendel\"),\n                                subfield = c(\"evolution\", \"genetics\", \"genetics\"))\nwhich(famous_biologists$subfield == \"genetics\")\n\n[1] 2 3\n\n\nThese results mean that rows 2 and 3 have their sub field category equal to genetics."
  },
  {
    "objectID": "document_dir/basics/using_rstudio.html",
    "href": "document_dir/basics/using_rstudio.html",
    "title": "Using R and RStudio",
    "section": "",
    "text": "Traditionally, R is installed to your local computer, allowing you to use it wherever and whenever you want to. However, here at Bowdoin, IT hosts an RStudio server on the High Performance Computing cluster. This allows you to not bog down your computer if you are running long, complex code, and it makes sure everyone has the same R environment when used in lab. The server is accessible from rstudio.bowdoin.edu as long as you are either connected to the Bowdoin internet network or to the Bowdoin VPN. Once there, you will be asked to sign in with your Bowdoin username and password. Make sure you use your Bowdoin username, and not your email! For example, if your email is ssdeeds@bowdoin.edu, then your username is ssdeeds.\n\n\n\nBowdoin RStudio log-in screen\n\n\nOnce you are logged in, you will now see the RStudio interface. This is where you can start using R!"
  },
  {
    "objectID": "document_dir/basics/using_rstudio.html#accessing-r-at-bowdoin",
    "href": "document_dir/basics/using_rstudio.html#accessing-r-at-bowdoin",
    "title": "Using R and RStudio",
    "section": "",
    "text": "Traditionally, R is installed to your local computer, allowing you to use it wherever and whenever you want to. However, here at Bowdoin, IT hosts an RStudio server on the High Performance Computing cluster. This allows you to not bog down your computer if you are running long, complex code, and it makes sure everyone has the same R environment when used in lab. The server is accessible from rstudio.bowdoin.edu as long as you are either connected to the Bowdoin internet network or to the Bowdoin VPN. Once there, you will be asked to sign in with your Bowdoin username and password. Make sure you use your Bowdoin username, and not your email! For example, if your email is ssdeeds@bowdoin.edu, then your username is ssdeeds.\n\n\n\nBowdoin RStudio log-in screen\n\n\nOnce you are logged in, you will now see the RStudio interface. This is where you can start using R!"
  },
  {
    "objectID": "document_dir/basics/using_rstudio.html#rstudio-interface",
    "href": "document_dir/basics/using_rstudio.html#rstudio-interface",
    "title": "Using R and RStudio",
    "section": "RStudio Interface",
    "text": "RStudio Interface\nRStudio is a type of software called an IDE (Integrated Developer Environment) that makes using R much easier than using R directly.\n\n\n\nRStudio Interface\n\n\nThe interface is split into 4 sections by default.\n\nThe top left is where files are open. Generally, this is where you are creating an R script, which is a text file with a list of R commands that are saved so you can use them later. You can run R code directly from the script through two main methods. If you highlight multiple rows of R code or click so your cursor is on one row and click the run button with the green arrow, then R will run the selected line(s) of code and the output will show up in the console (discussed below). If you want to run the whole file, you can use the Source button.\nThe bottom left is the R console, where R itself lives. You can type commands for R to process into this screen and when entered, R will process them. However, commands entered here are not saved, so making an R script is recommended. This is also where any output from R scripts will appear. A handy feature is if you hit the up arrow on your keyboard, the last command run will appear in the console, allowing for it to be run again. This can be repeated multiple times to more easily run a command you previously used\nThe top right is the environment window. When you import datasets into R or create variables to store information, they will show up here.\nThe bottom right is the information window, where you can access the File, Plots, Packages, and Help tabs. File allows you to access files in your directory for use in RStudio. Plots is where graphs you make will appear. Packages is where the add-on packages you can install and load will appear, and help is a manual for R commands that is easily accessible."
  },
  {
    "objectID": "document_dir/basics/using_rstudio.html#files-location",
    "href": "document_dir/basics/using_rstudio.html#files-location",
    "title": "Using R and RStudio",
    "section": "Files Location",
    "text": "Files Location\nFiles that the RStudio server uses and can access live in your Bowdoin Microwave storage space. This is 10 gigabytes of storage that Bowdoin hosts on their servers that is automatically backed up on a regular basis. This is where you will want to store your data files and R scripts for ease of use. This storage can be accessed by opening the Finder application and clicking the Go button at the top menu bar. Click the Connect to Server… button, which will open a window that looks like the one below.\nTo connect to your Microwave drive, put the drive location in the top field. This will be smb://microwave.bowdoin.edu/home/username with the username being your Bowdoin username. Once you click connect, you will be asked to log in with your Bowdoin credentials. Once you submit your username and password, a finder window will open and contain your Microwave drive."
  },
  {
    "objectID": "document_dir/basics/using_rstudio.html#mini-check",
    "href": "document_dir/basics/using_rstudio.html#mini-check",
    "title": "Using R and RStudio",
    "section": "Mini Check",
    "text": "Mini Check\n\nHow do you access the Bowdoin RStudio Server?\n\n Download R on your computer Go to rstudio.bowdoin.edu Go to cran.r-project.org\n\nWhere should you put files that you want to use in R?\n\n Upload them to Microwave Download them to the desktop R already has all of your files\n\nYou have a set of R commands you want to use many times. What is the best way to run them?\n\n Type each command in the console one by one Copy and paste them from a Word document Run your commands from a saved R script"
  },
  {
    "objectID": "document_dir/basics/basic_functions.html",
    "href": "document_dir/basics/basic_functions.html",
    "title": "Functions",
    "section": "",
    "text": "At the core of using R is utilizing functions, which are statements that takes in data and a set of parameters and returns an object with something being done to the data provided. Functions are how you read in your data sets, clean them up, do statistical analyses, and visualize your data. You can even make your own!\n\n\nBefore we get into some basic and common functions, one must first understand the components of a function. Below is the mean function, which as the name implies, finds the mean of a given set of values.\n\nfav_nums &lt;- c(1,5,12,8,58) #Making a vector of values\nmean_fav &lt;- mean(x = fav_nums, na.rm = TRUE)\nmean_fav\n\n[1] 16.8\n\n\nThe structure of a function is the function’s name followed by a set of parentheses. For some functions that require no additional information, that is all you need. However, most functions require providing data objects and parameters so that the function is applied to a specific object in a specific way. For example, in the mean()function above, there are two parameters:xandna.rm\nIn this case, the x parameter is where we provide the data object that mean() uses. We assign the data object fav_nums to the x parameter using the parameter assignment operator, =. Generally, the very first parameter of a function will be where you provide the data object.\nSimilarly to assigning the fav_nums object to x, the logical value TRUE is assigned to the na.rm parameter, which tells the mean() function to remove any NA values in the provided set of numbers if there was any.\nSomething that makes writing functions easier is that there is a given order of parameters in a specific function. For the mean() function, there are three named parameters: x, trim, and na.rm. Rather than having to provide the parameter name, you can just provide the value for the parameter instead of the full parameter = value statement.\n\nmean_fav &lt;- mean(fav_nums)\nmean_fav\n\n[1] 16.8\n\n\nAdditionally, functions can have some parameters have default values. These default values are what a function uses if you do not provide an alternative value. An example of this is for the first usage of the mean() function. I did not provide a value for the trim parameter, yet the function still worked. This is because the mean() function provides a default value for that parameter. You can override that default value by setting the parameter to what you wish. An example is that the default parameter value for na.rm for the mean() function is FALSE, but I set na.rm to TRUE.\nThe most readily available source of information for understanding what a function does and what the specific parameters it uses is the help tab in RStudio. You can search by the function name and it will provide a reference guide to the function."
  },
  {
    "objectID": "document_dir/basics/basic_functions.html#function-syntax",
    "href": "document_dir/basics/basic_functions.html#function-syntax",
    "title": "Functions",
    "section": "",
    "text": "Before we get into some basic and common functions, one must first understand the components of a function. Below is the mean function, which as the name implies, finds the mean of a given set of values.\n\nfav_nums &lt;- c(1,5,12,8,58) #Making a vector of values\nmean_fav &lt;- mean(x = fav_nums, na.rm = TRUE)\nmean_fav\n\n[1] 16.8\n\n\nThe structure of a function is the function’s name followed by a set of parentheses. For some functions that require no additional information, that is all you need. However, most functions require providing data objects and parameters so that the function is applied to a specific object in a specific way. For example, in the mean()function above, there are two parameters:xandna.rm\nIn this case, the x parameter is where we provide the data object that mean() uses. We assign the data object fav_nums to the x parameter using the parameter assignment operator, =. Generally, the very first parameter of a function will be where you provide the data object.\nSimilarly to assigning the fav_nums object to x, the logical value TRUE is assigned to the na.rm parameter, which tells the mean() function to remove any NA values in the provided set of numbers if there was any.\nSomething that makes writing functions easier is that there is a given order of parameters in a specific function. For the mean() function, there are three named parameters: x, trim, and na.rm. Rather than having to provide the parameter name, you can just provide the value for the parameter instead of the full parameter = value statement.\n\nmean_fav &lt;- mean(fav_nums)\nmean_fav\n\n[1] 16.8\n\n\nAdditionally, functions can have some parameters have default values. These default values are what a function uses if you do not provide an alternative value. An example of this is for the first usage of the mean() function. I did not provide a value for the trim parameter, yet the function still worked. This is because the mean() function provides a default value for that parameter. You can override that default value by setting the parameter to what you wish. An example is that the default parameter value for na.rm for the mean() function is FALSE, but I set na.rm to TRUE.\nThe most readily available source of information for understanding what a function does and what the specific parameters it uses is the help tab in RStudio. You can search by the function name and it will provide a reference guide to the function."
  },
  {
    "objectID": "document_dir/data_wrangling/importing_data.html",
    "href": "document_dir/data_wrangling/importing_data.html",
    "title": "Importing Data",
    "section": "",
    "text": "During your time with R, you will be working with data from various sources. Whether these data files are given to you or you make them yourself, they all will share some common traits. Data files to be used in R are normally rectangular, meaning they are in the format of rows (horizontal) and columns (vertical). Columns commonly have labels, called headers. R will normally treat the first row of a data file as the headers of your data. However, best practice indicates that rows should not include labels. R will treat row labels as just another column of data, which can cause complications in future data wrangling.\n\n\n\n\n\n\nNote\n\n\n\nIf you are making your own data files, try to keep column header labels short, simple, and descriptive. They will be used extensively as you process your data, so efficient labels enable you to be more efficient. Try to keep them all one case (either all uppercase or lowercase), do not use spaces, and limit special characters to _ or . (and stay consistent on which character you use as a word separator if you choose to use one).\n\n\nAdditionally, keep R data objects in mind when you are making or editing your data files. Most data files are imported as dataframes. Due to the constraints of dataframes, keep the data values in each column the same R data type. For example, If you have a column for recording the height of someone, each entry should be a numeric. If you were to mix in a string, such as “six feet”, then you will experience difficulty later when you are using your data.\nR will do its best to determine what data type each column should be during the importation process. However, it can make mistakes. We will cover how to handle that in a later section."
  },
  {
    "objectID": "document_dir/data_wrangling/importing_data.html#anatomy-of-data-files",
    "href": "document_dir/data_wrangling/importing_data.html#anatomy-of-data-files",
    "title": "Importing Data",
    "section": "",
    "text": "During your time with R, you will be working with data from various sources. Whether these data files are given to you or you make them yourself, they all will share some common traits. Data files to be used in R are normally rectangular, meaning they are in the format of rows (horizontal) and columns (vertical). Columns commonly have labels, called headers. R will normally treat the first row of a data file as the headers of your data. However, best practice indicates that rows should not include labels. R will treat row labels as just another column of data, which can cause complications in future data wrangling.\n\n\n\n\n\n\nNote\n\n\n\nIf you are making your own data files, try to keep column header labels short, simple, and descriptive. They will be used extensively as you process your data, so efficient labels enable you to be more efficient. Try to keep them all one case (either all uppercase or lowercase), do not use spaces, and limit special characters to _ or . (and stay consistent on which character you use as a word separator if you choose to use one).\n\n\nAdditionally, keep R data objects in mind when you are making or editing your data files. Most data files are imported as dataframes. Due to the constraints of dataframes, keep the data values in each column the same R data type. For example, If you have a column for recording the height of someone, each entry should be a numeric. If you were to mix in a string, such as “six feet”, then you will experience difficulty later when you are using your data.\nR will do its best to determine what data type each column should be during the importation process. However, it can make mistakes. We will cover how to handle that in a later section."
  },
  {
    "objectID": "document_dir/data_wrangling/importing_data.html#data-formats",
    "href": "document_dir/data_wrangling/importing_data.html#data-formats",
    "title": "Importing Data",
    "section": "Data Formats",
    "text": "Data Formats\nThe first step to working with data in R is to import data in a common format into your R session. Data in the form of tables are normally provided in either an excel (.xlsx) or comma separated format (.csv). The excel format can only be opened in Microsoft Excel or other specialty programs. CSV files are text files that separate columns in each row using a separator character, commonly a comma (hence the name!).\nExcel files provide additional features that can be both useful and cause complications when importing them to R. While they support multiple sheets in one file, equations, color formatting, and more, these features are not supported in R. Try to keep your data files simple and readable.\n\n\n\n\n\n\nCaution\n\n\n\nDo not use Apple Numbers to open provided .xlsx or CSV files! Automatic changes done to the file when opened by Numbers will cause the file to fail to import to R.\n\n\nCSV files are much simpler than Excel files but can be more difficult to use to a beginner. They can be opened using Excel or a text editor such as TextEdit or BBEdit. However, be careful when using a text editor! Make sure it is set to save files in a plain text format. Many editors default to rich text, which supports different fonts and features common in files such as Word documents. However, the formatting will confuse R when you try to import the file."
  },
  {
    "objectID": "document_dir/data_wrangling/importing_data.html#importing-data-using-base-r",
    "href": "document_dir/data_wrangling/importing_data.html#importing-data-using-base-r",
    "title": "Importing Data",
    "section": "Importing Data Using Base R",
    "text": "Importing Data Using Base R\nR can natively import CSV files using the function read.csv(). However, before we can use the function, we have to tell R where to look for files. To do so, you have to set your working directory. A working directory is a folder where R looks for your scripts and files that you use in your scripts. The easiest way to set this is to go to the folder in the file pane then, in the menu bar, click Session -&gt; Set Working Directory -&gt; To Files Pane Location.\nOnce your working directory is set, we can import our files. If we had a CSV file in our working directory, then we would use the following function to assign the dataframe to variable:\n\nour_data &lt;- read.csv(\"data_file.csv\")\n\nThis function reads the CSV file called data_file.csv that exists in the set working directory and assigns it to the variable our_data. By default, read.csv() assumes that the first row of data is the header labels, the separator character is a comma, and there are not row names. If your file does not follow these assumptions, then you can use the generic read.table() function and set the necessary parameters. For example, if my CSV had no header labels and used semicolons as the separator:\n\ndifferent_data &lt;- read.table(\"another_data_file.csv\", header = FALSE, sep = \";\")\n\nMore information regarding the parameters available in the read.() function family can be found in the help menu."
  },
  {
    "objectID": "document_dir/data_wrangling/importing_data.html#importing-excel-files",
    "href": "document_dir/data_wrangling/importing_data.html#importing-excel-files",
    "title": "Importing Data",
    "section": "Importing Excel Files",
    "text": "Importing Excel Files\nBase R is not able to read the proprietary format that Excel files use. However, we can use a package to expand R, enabling the importing of Excel files. The package readxl is a part of the Tidyverse family of packages and should already be installed on the Bowdoin R Studio server. The function read_xlsx() is the Excel equivalent to the read.csv() function you learned about above.\n\nlibrary(readxl) #Remember! To use a package, you first have to load it into your library!\nexcel_data &lt;- read_xlsx(\"excel_data.xlsx\")\n\nThe read_xlsx() assumes that your excel file is one sheet and has header labels."
  },
  {
    "objectID": "document_dir/about/guide_license.html",
    "href": "document_dir/about/guide_license.html",
    "title": "Guide License",
    "section": "",
    "text": "This guide and all related software is licensed under the MIT license. The author and/or copyright holder(s) maintain the right to change the license used.\nCopyright (c) 2023 Aale J. Agans & Hawkwood Research Group\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "document_dir/about/other_software_licenses.html",
    "href": "document_dir/about/other_software_licenses.html",
    "title": "Incorporated Software & Media",
    "section": "",
    "text": "The R software is licensed under the General Public License version 2 or Later. The language of the licensing can be accessed using the command below:\nRShowDoc(\"GPL-3\")\nThe tidyverse packages, including dplyr, ggplot2, tidyr, and others are licensed under the MIT license, which can be accessed here.\nQuarto, the framework used to build this guide, is licensed under the General Public License version 2, which can be accessed here.\nThe RStudio IDE software is provided under the Affero General Public License version 3, which can be accessed here.\nThe webR package is licensed under the MIT license with the binaries licensed under the General Public License version 3. Information can be accessed here.\nThe icon is an adaption, (c) Joseph Gage, some rights reserved (CC BY-SA)"
  },
  {
    "objectID": "document_dir/about/other_software_licenses.html#licensing-statements-for-incorporated-software",
    "href": "document_dir/about/other_software_licenses.html#licensing-statements-for-incorporated-software",
    "title": "Incorporated Software & Media",
    "section": "",
    "text": "The R software is licensed under the General Public License version 2 or Later. The language of the licensing can be accessed using the command below:\nRShowDoc(\"GPL-3\")\nThe tidyverse packages, including dplyr, ggplot2, tidyr, and others are licensed under the MIT license, which can be accessed here.\nQuarto, the framework used to build this guide, is licensed under the General Public License version 2, which can be accessed here.\nThe RStudio IDE software is provided under the Affero General Public License version 3, which can be accessed here.\nThe webR package is licensed under the MIT license with the binaries licensed under the General Public License version 3. Information can be accessed here.\nThe icon is an adaption, (c) Joseph Gage, some rights reserved (CC BY-SA)"
  },
  {
    "objectID": "document_dir/about/about.html",
    "href": "document_dir/about/about.html",
    "title": "Purpose",
    "section": "",
    "text": "This R guide was created by Aale J. Agans at the Hawkwood Research Group for the Bowdoin College Biology Department. The purpose of the guide is to provide a comprehensive intro to the usage of R in an academic setting, establish good practices to enable further learning, and the specific applications of R for the biological sciences. This guide is currently under development!"
  },
  {
    "objectID": "document_dir/about/author_info.html",
    "href": "document_dir/about/author_info.html",
    "title": "The Author",
    "section": "",
    "text": "Aale J. Agans is an undergraduate student at Bowdoin College majoring in evolutionary and ecological biology with interests in ecological genetics and the evolution of symbiosis in terrestrial systems. As a proponent for open and free access in academia, most of their work in bioinformatics is developing applications and pipelines that are accessible and easy to use for researchers at all levels."
  },
  {
    "objectID": "document_dir/about/author_info.html#education",
    "href": "document_dir/about/author_info.html#education",
    "title": "The Author",
    "section": "Education",
    "text": "Education\nBowdoin College | Brunswick, ME\nB.A. in Biology; Evolution, Ecology, and Marine Biology Concentration | August 2021 - Present"
  },
  {
    "objectID": "document_dir/about/author_info.html#experience",
    "href": "document_dir/about/author_info.html#experience",
    "title": "The Author",
    "section": "Experience",
    "text": "Experience\nBioinformatics Lead | Hawkwood Research Group | August 2023 - Present\nResearch Assistant | Bowdoin College | January 2023 - Present\nR Learning Assistant | Bowdoin College | August 2023 - Present"
  },
  {
    "objectID": "document_dir/data_visualization/visualization.html",
    "href": "document_dir/data_visualization/visualization.html",
    "title": "Visualizing Data",
    "section": "",
    "text": "One of the key ways to explore and present your data is through graphing it. R is an excellent way to make all types of graphs, ranging from rough-draft level to publication-ready figures. While you may see references to base R graphing in other sources, our focus is on using the ggplot2 package, a package that is a part of the Tidyverse collection of packages that make every step of working with data easier.\n\n\nThe basis of ggplot2 is the ggplot() function. Using this function, you initialize your graph and provide the data that you want to plot. Think of this as the foundation of your graph. While it is not visible (as this function does not produce anything by itself), it is what the architecture of the graph rests on. The two main parameters are data and mapping. The first one is where you provide your data object and the second is how you tell ggplot what columns in your data correspond to what parts of the graph, such as the x or y axis.\nHere is an example from the iris data set built into R:\nggplot(data = iris, mapping = aes(x = Species))\nTake note of the use of the aes() function in the mapping parameter declaration. This function acts as a helper, formatting the axis and group assignments of data columns into a form that the ggplot() function understands. A common error is forgetting the aes() function.\nHowever, you may have noticed that nothing has been plotted. While we have told R what data to use and how to assign our different variables, we need to now tell it how we wish the data to be represented. This is when we use one of the many geom (short for geometry) functions. Now that the foundation is set, we can start building the house!\nOne of the most basic and useful graphs you may encounter is the humble bar graph. By using the geom function geom_bar(), we can make a bar plot based on our cars data.\nggplot(data = iris, mapping = aes(x = Species)) +\n  geom_bar()\nNotice how the two functions are combined using a plus sign. This is how ggplot2 connects functions, enabling us to build a graph without needing to use one very long function that would quickly become inconvenient. The geom_bar() function inherits the data and variable mappings from the ggplot() function, where it then visualizes the data accordingly. Since the data was previously provided, the geom_bar() function requires no specialized parameters, and I am happy with the default look, we do not have to provide any parameters to the function. Lets see what happens when we run these commands!\n\nlibrary(ggplot2) #Loading ggplot2 package\ndata(\"iris\") #Loading the built-in mtcars data set\n\nggplot(data = iris, mapping = aes(x = Species)) +\n  geom_bar()\n\n\n\n\nWhile this isn’t the most exciting graph, it is informative. It tells us that there are three species of irises in this data set, each with 50 observations. However, what if we wanted to make it so that we graphed the mean petal width by species? Then we need to provide make a few changes. First, we have to tell theggplot() command that our y values will come from the Petal.Width column. Second, we have to tell the geom to find the mean value of the pedal widths. Lets try!\nFirst, lay our foundation:\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Width))\nNext, lets make our graph:\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Width)) +\n  geom_bar(stat = \"summary\", fun = \"mean\")\n\n\n\n\nNotice the stat and fun parameters in the geom_bar() function? That is what tells ggplot to take the mean petal width rather than counting every data entry or adding them all together. The stat parameter tells the geom how to compute the data. By default in the geom_bar() function, it is set to count, where it counts the number of data entries per x value and graphs that. That is what we saw above with the different species. As a mean is a summary statistic, we have to tell ggplot to set the stat to \"summary\". However, there are many different types of summary statistics, so we use the fun parameter to tell it to use the mean function. This makes our lovely plot! The next steps are to explore the options beyond simple bar plots and learn how to customize our graphs to be more visually pleasing."
  },
  {
    "objectID": "document_dir/data_visualization/visualization.html#syntax-of-ggplot2",
    "href": "document_dir/data_visualization/visualization.html#syntax-of-ggplot2",
    "title": "Visualizing Data",
    "section": "",
    "text": "The basis of ggplot2 is the ggplot() function. Using this function, you initialize your graph and provide the data that you want to plot. Think of this as the foundation of your graph. While it is not visible (as this function does not produce anything by itself), it is what the architecture of the graph rests on. The two main parameters are data and mapping. The first one is where you provide your data object and the second is how you tell ggplot what columns in your data correspond to what parts of the graph, such as the x or y axis.\nHere is an example from the iris data set built into R:\nggplot(data = iris, mapping = aes(x = Species))\nTake note of the use of the aes() function in the mapping parameter declaration. This function acts as a helper, formatting the axis and group assignments of data columns into a form that the ggplot() function understands. A common error is forgetting the aes() function.\nHowever, you may have noticed that nothing has been plotted. While we have told R what data to use and how to assign our different variables, we need to now tell it how we wish the data to be represented. This is when we use one of the many geom (short for geometry) functions. Now that the foundation is set, we can start building the house!\nOne of the most basic and useful graphs you may encounter is the humble bar graph. By using the geom function geom_bar(), we can make a bar plot based on our cars data.\nggplot(data = iris, mapping = aes(x = Species)) +\n  geom_bar()\nNotice how the two functions are combined using a plus sign. This is how ggplot2 connects functions, enabling us to build a graph without needing to use one very long function that would quickly become inconvenient. The geom_bar() function inherits the data and variable mappings from the ggplot() function, where it then visualizes the data accordingly. Since the data was previously provided, the geom_bar() function requires no specialized parameters, and I am happy with the default look, we do not have to provide any parameters to the function. Lets see what happens when we run these commands!\n\nlibrary(ggplot2) #Loading ggplot2 package\ndata(\"iris\") #Loading the built-in mtcars data set\n\nggplot(data = iris, mapping = aes(x = Species)) +\n  geom_bar()\n\n\n\n\nWhile this isn’t the most exciting graph, it is informative. It tells us that there are three species of irises in this data set, each with 50 observations. However, what if we wanted to make it so that we graphed the mean petal width by species? Then we need to provide make a few changes. First, we have to tell theggplot() command that our y values will come from the Petal.Width column. Second, we have to tell the geom to find the mean value of the pedal widths. Lets try!\nFirst, lay our foundation:\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Width))\nNext, lets make our graph:\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Width)) +\n  geom_bar(stat = \"summary\", fun = \"mean\")\n\n\n\n\nNotice the stat and fun parameters in the geom_bar() function? That is what tells ggplot to take the mean petal width rather than counting every data entry or adding them all together. The stat parameter tells the geom how to compute the data. By default in the geom_bar() function, it is set to count, where it counts the number of data entries per x value and graphs that. That is what we saw above with the different species. As a mean is a summary statistic, we have to tell ggplot to set the stat to \"summary\". However, there are many different types of summary statistics, so we use the fun parameter to tell it to use the mean function. This makes our lovely plot! The next steps are to explore the options beyond simple bar plots and learn how to customize our graphs to be more visually pleasing."
  },
  {
    "objectID": "document_dir/data_visualization/common_edits.html",
    "href": "document_dir/data_visualization/common_edits.html",
    "title": "Common Visual Edits",
    "section": "",
    "text": "While it is straightforward to make a graph using ggplot2 in R, it can be difficult to make it look exactly how you want it to. A lot of the default settings do make a good graph, but there are a few common tweaks that are an easy way to bring your plots to a whole new level."
  },
  {
    "objectID": "document_dir/data_visualization/common_edits.html#mappings-text",
    "href": "document_dir/data_visualization/common_edits.html#mappings-text",
    "title": "Common Visual Edits",
    "section": "Mappings Text",
    "text": "Mappings Text\nUsing our iris plot as an example, we see that ggplot2 will default to using column headers as labels.\n\nlibrary(ggplot2) #Loading ggplot2 package\ndata(\"iris\") #Loading the built-in mtcars data set\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Width)) +\n  geom_bar(stat = \"summary\", fun = \"mean\")\n\n\n\n\nHowever, often these headers use unusual punctuation or shortenings that are confusing to people who are viewing the graph. Here is how we change that:\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Width)) +\n  geom_bar(stat = \"summary\", fun = \"mean\") +\n  labs(x = \"Iris Species\", y = \"Petal Width (mm)\")\n\n\n\n\nUsing the labs() function, you can set the text label for any of the mappings you set in the aes() function."
  },
  {
    "objectID": "document_dir/data_visualization/common_edits.html#axis-breaks-limits",
    "href": "document_dir/data_visualization/common_edits.html#axis-breaks-limits",
    "title": "Common Visual Edits",
    "section": "Axis Breaks & Limits",
    "text": "Axis Breaks & Limits\nYou may also want to change the text labels for each iris species. Those labels are axis break labels, as each tick is break on the axis. As there are two main types of axes, each axis has two main functions to set the break labels.\n\nDiscrete Axes\nAn axis is considered discrete when each variable on the axis is its own group. For example, each break represents one species, such as the iris graph above. These are most commonly the x axis or the color/fill grouping.\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Width)) +\n  geom_bar(stat = \"summary\", fun = \"mean\") +\n  labs(x = \"Iris Species\", y = \"Petal Width (mm)\") +\n  scale_x_discrete(labels = c(\"Setosa\", \"Versicolor\", \"Virginica\"))\n\n\n\n\nBy default, R will sort discrete groups alphabetically. If you want to change that, we can use the limits parameter of the scale_x_discrete() function:\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Width)) +\n  geom_bar(stat = \"summary\", fun = \"mean\") +\n  labs(x = \"Iris Species\", y = \"Petal Width (mm)\") +\n  scale_x_discrete(limits = c(\"virginica\", \"setosa\", \"versicolor\"), \n                   labels = c(\"Virginica\", \"Setosa\", \"Versicolor\"))\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nMake sure you re-order your labels when you re-order your discrete limits! Otherwise, you can end up with a group called Virginica which is actually Setosa.\n\n\n\n\nContinuous Axes\nAn axis is considered continuous when it is composed of a range of numbers where a value can exist anywhere within that range. For example, most numeric measurements, such as height or length, would be continuous. This is most commonly the y axis, like in our iris plot. While R is good at guessing the range that best fits, sometimes you may want to edit the lower and upper limits. A good example of when you would want to do this is if you want two different graphs to be comparable.\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Width)) +\n  geom_bar(stat = \"summary\", fun = \"mean\") +\n  labs(x = \"Iris Species\", y = \"Petal Width (mm)\") +\n  scale_x_discrete(limits = c(\"virginica\", \"setosa\", \"versicolor\"), \n                   labels = c(\"Virginica\", \"Setosa\", \"Versicolor\")) +\n  scale_y_continuous(limits = c(0, 5))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An R Guide for Bowdoin Biology Students",
    "section": "",
    "text": "Welcome! to the guide for using R as a biology student at Bowdoin College! This guide will act as a comprehensive introduction to the R statistical programming language and its applications in the field of biology. Included in this guide are: an introduction to using R, an overview of R structure, data manipulation, data visualization/graphing, statistical analyses, biology-specific packages, and intermediate/advanced R use cases. This guide can be used by complete R beginners, people with experience with other programming languages, and even people with R experience outside the field of biology.\n\nWhat is R?\nR is a statistical programming language developed by Ross Ihaka and Robert Gentleman.1 Based on the principles of free (as in freedom) open source software (FOSS), the R programming language is freely available at the Comprehensive R Archive Newtork (CRAN) and can run on Windows, Linus, and MacOS platforms.\nSo why use R instead of other statistical packages, such as SPSS, SAS, Stata, Prism, or others?\n\nIt is a standard tool in most academic disciplines that use statistical analyses for research and industry.2 In fact, over 54% of all published literature articles in the top 30 journals in ecology used R.3\nR has an active community supporting it. Tens of thousands of packages, the main way of extended R’s capabilities, have been created and are actively maintained.4\nDue to its open source nature, the source code can be freely investigated, ensuring confidence in its accuracy.\nIt is free!\n\n\n\nWhat can I do with R?\nR is a programming language, so almost anything you can think of! However, you most likely would not want to make a video game using R. R is specialized to statistical analysis and data science. We will be using it to process our data, run statistical tests, and to graph our results. However, this is just the tip of the iceberg of what you can do with R! From analyzing genomic data sets, to creating machine learning models, to GIS analysis, R can do it all and even more.\n\n\nHow do I use this guide?\nThis guide is broken into different sections that each cover information about R. In these sections, there will be text explanations such as this, and also code blocks with relevant R code. By pressing the “Run code” button, the program will run and you will be able to see the results below the block. For example, try this simple code block:\nLoading\n  webR...\n\n\n  \n\n\nIf it was successful, then you should see a result that says 2. Additionally, there will be some code blocks without the “Run code” button, which are just to explain specific concepts. See below:\nvar &lt;- 1\ntwo.var &lt;- var + var\nFor some code blocks, there will be code annotations on the right side that appear when you hover your mouse cursor over the icon.\n1var &lt;- 1\n\n1\n\nHere is a code annotation!\n\n\n\n\n\n\n\nReferences\n\n1. Giorgi FM, Ceraolo C, Mercatelli D. The r language: An engine for bioinformatics and data science. Life. 2022;12(5):648. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9148156/. doi:10.3390/life12050648\n\n\n2. Muenchen R. The popularity of data science software | r4stats.com. 2012. https://r4stats.com/articles/popularity/\n\n\n3. Lai J, Lortie CJ, Muenchen RA, Yang J, Ma K. Evaluating the popularity of R in ecology. Ecosphere. 2019;10(1):e02567. https://onlinelibrary.wiley.com/doi/abs/10.1002/ecs2.2567. doi:10.1002/ecs2.2567\n\n\n4. The comprehensive r archive network. https://cran.r-project.org/"
  }
]